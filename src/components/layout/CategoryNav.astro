---
import type { Category } from "../../types";
import { candyColors } from "../../lib/colors";
import SafeIcon from "../ui/SafeIcon.astro";

interface Props {
    categories: Category[];
    linkCounts: Map<string, number>;
}

const { categories, linkCounts } = Astro.props;
---

<nav class="category-nav space-y-1.5" aria-label="Category Navigation">
    {
        categories.map((category, idx) => {
            const count = linkCounts.get(category.id) || 0;
            if (count === 0) return null;

            const color = candyColors[idx % candyColors.length];

            return (
                <a
                    href={`#category-${category.id}`}
                    data-category-id={category.id}
                    class="category-nav-item group flex items-center gap-3 px-3 py-2.5 rounded-xl
                           bg-white/40 dark:bg-zinc-900/40
                           border border-transparent
                           hover:bg-white/60 dark:hover:bg-zinc-900/60
                           hover:border-white/40 dark:hover:border-zinc-700/40
                           transition-all duration-200
                           cursor-pointer"
                >
                    {/* Icon with color */}
                    <div
                        class={`w-8 h-8 rounded-lg flex items-center justify-center flex-shrink-0 ${color.bg} ${color.text} transition-transform duration-200 group-hover:scale-110`}
                    >
                        <SafeIcon
                            name={category.icon}
                            fallbackText={category.title}
                            class="w-4 h-4"
                            fallbackClass="text-xs font-bold"
                        />
                    </div>

                    {/* Title */}
                    <span class="flex-1 text-lg font-bold text-zinc-800 dark:text-zinc-200 truncate">
                        {category.title}
                    </span>

                    {/* Count badge */}
                    <span
                        class={`px-2 py-0.5 text-xs font-bold rounded-full flex-shrink-0 ${color.bg} ${color.text}`}
                    >
                        {count}
                    </span>
                </a>
            );
        })
    }
</nav>

<script>
    function initCategoryNav() {
        const navItems = document.querySelectorAll(".category-nav-item");

        // Select category headers, not sections
        const categoryHeaders = document.querySelectorAll(".category-header");

        console.log('[CategoryNav] Init:', {
            navItems: navItems.length,
            categoryHeaders: categoryHeaders.length
        });

        if (navItems.length === 0 || categoryHeaders.length === 0) {
            console.warn('[CategoryNav] Cannot init: Missing elements');
            return;
        }

        // Smooth scroll handler
        navItems.forEach((item, index) => {
            item.addEventListener("click", (e) => {
                console.log(`[CategoryNav] Clicked nav item ${index}`);
                e.preventDefault();
                const categoryId = item.getAttribute("data-category-id");
                console.log(`[CategoryNav] Category ID: ${categoryId}`);

                // Try to find section by ID first (more specific)
                let section = document.querySelector(`#category-${categoryId}`);

                // Fallback to data-category attribute if ID not found
                if (!section) {
                    console.warn(`[CategoryNav] Section by ID not found, trying data-category`);
                    section = document.querySelector(
                        `[data-category="${categoryId}"]`,
                    );
                }

                console.log(`[CategoryNav] Section found:`, !!section);

                if (section) {
                    console.log(`[CategoryNav] Scrolling to section`);
                    section.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });

                    // Update URL hash without scroll
                    history.pushState(null, '', `#category-${categoryId}`);
                } else {
                    console.error(`[CategoryNav] Section not found for category: ${categoryId}`);
                }
            });
        });

        // Intersection observer for category headers only
        const observerOptions = {
            root: null,
            rootMargin: "0px 0px -90% 0px", // Only top 10% of viewport
            threshold: 0,
        };

        const observer = new IntersectionObserver((entries) => {
            // Find all visible headers directly from entries
            const visibleEntries = entries.filter(
                (entry) => entry.isIntersecting,
            );

            if (visibleEntries.length > 0) {
                // Get the topmost visible header using entry.boundingClientRect
                const topmostEntry = visibleEntries.reduce(
                    (topmost, current) => {
                        return current.boundingClientRect.top <
                            topmost.boundingClientRect.top
                            ? current
                            : topmost;
                    },
                );

                const categoryId = topmostEntry.target
                    .closest("[data-category]")
                    ?.getAttribute("data-category");

                if (categoryId) {
                    // Remove active from all
                    navItems.forEach((nav) => {
                        nav.classList.remove("active");
                    });

                    // Add active to matching
                    const activeNav = document.querySelector(
                        `.category-nav-item[data-category-id="${categoryId}"]`,
                    );
                    if (activeNav) {
                        activeNav.classList.add("active");
                    }
                }
            }
        }, observerOptions);

        categoryHeaders.forEach((header) => observer.observe(header));
    }

    // Initialize with retry logic
    if (typeof window !== "undefined") {
        const tryInit = () => {
            initCategoryNav();

            // Retry once if init failed (might be timing issue)
            setTimeout(() => {
                const navItems = document.querySelectorAll(".category-nav-item");
                const categoryHeaders = document.querySelectorAll(".category-header");

                if (navItems.length > 0 && categoryHeaders.length > 0) {
                    console.log('[CategoryNav] Retry - elements found, re-initializing');
                    initCategoryNav();
                }
            }, 500);
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", tryInit);
        } else {
            // Add small delay to ensure all components are mounted
            setTimeout(tryInit, 100);
        }
    }
</script>

<style>
    .category-nav-item.active {
        background-color: rgb(255 255 255 / 0.95);
        border-color: rgb(127 115 255 / 0.4);
        box-shadow:
            0 4px 12px -2px rgb(127 115 255 / 0.15),
            0 2px 6px -1px rgb(0 0 0 / 0.1);
    }

    :global(.dark) .category-nav-item.active {
        background-color: rgb(39 39 42 / 0.9);
        border-color: rgb(82 82 91 / 0.5);
    }
</style>
